"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NET_PREFIX = exports.Account = void 0;

var _utilCrypto = require("@polkadot/util-crypto");

var _keyring = require("@polkadot/keyring");

var _defaults = require("@polkadot/keyring/pair/defaults");

var _util = require("@polkadot/util");

var _u8aFrom = _interopRequireDefault(require("./u8aFrom"));

var _decode = _interopRequireDefault(require("@polkadot/keyring/pair/decode"));

var _encode = _interopRequireDefault(require("@polkadot/keyring/pair/encode"));

// eslint-disable-next-line header/header
const NET_PREFIX = {
  testnet: 42,
  // eslint-disable-next-line sort-keys
  mainnet: 44
};
/**
 * interface KeyPair contains publickey and secretKey.
 *
*/

exports.NET_PREFIX = NET_PREFIX;

/**
 * 保持兼容 @polkadot/keyring/pair
 */
class Account {
  /**
     * user publickKey and privateKey
    */

  /**
     * generate a account
    */
  constructor(keyPair) {
    this._keyPair = void 0;
    this._keyPair = keyPair;
    (0, _keyring.setSS58Format)(NET_PREFIX.testnet);
  }
  /**
     * generate mainnet account or testnet account
     * @param net  NET_PREFIX.textnet || NET_PREFIX.mainnet
     * @return void
     *
    */


  static setNet(net) {
    if (!net) {
      throw new Error('expect pass in the network type, testnet or mainnet');
    }

    if (net === NET_PREFIX.mainnet || net === NET_PREFIX.testnet) {
      (0, _keyring.setSS58Format)(net);
    }
  }
  /**
     * get private key
     * @return string
    */


  privateKey() {
    return (0, _util.u8aToHex)(this._keyPair.secretKey.subarray(0, 32));
  }
  /**
    * @name publicKey
    * @summary
    * @description
    * Returns message of 'address', which is string type.
    */


  publicKey() {
    return (0, _util.u8aToHex)(this._keyPair.publicKey);
  }
  /**
    * @name address
    * @summary
    * @description
    * Returns message of 'address', which is string type.
    */


  address() {
    return (0, _keyring.encodeAddress)(this.publicKey());
  }
  /**
    * @name sign
    * @summary Signs a message using the supplied secretKey
    * @description
    * Returns message signature of `message`, using the `secretKey`.
    * @example
    * <BR>
    *
    * ```javascript
    * import { sign } from '@chainx-v2/account';
    *
    * sign([...], [...]); // => [...]
    * ```
    */


  sign(message) {
    return (0, _utilCrypto.naclSign)(message, this._keyPair);
  }
  /**
    * @name verify
    * @summary Validate that the message was correctly signed
    * @description
    * Returns result of verify
    */


  verify(message, signature) {
    return (0, _utilCrypto.naclVerify)(message, signature, this._keyPair.publicKey);
  }
  /**
    * @name from
    * @summary generate account using unkwon string, which is seed, privatekey,keystore...
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static from(unknow) {
    if (Account.isMnemonicValid(unknow)) {
      return Account.fromMnemonic(unknow);
    }

    if (typeof unknow !== 'string') {
      const u8a = (0, _u8aFrom.default)(unknow);

      if (u8a.length === 32) {
        return new Account((0, _utilCrypto.naclKeypairFromSeed)(u8a));
      } else if (u8a.length === 64) {
        return new Account((0, _utilCrypto.naclKeypairFromSecret)(u8a));
      } else {
        throw new Error('unexpect value');
      }
    } else if ((0, _util.isHex)(unknow, 512)) {
      return Account.fromSecretKey(unknow);
    } else if ((0, _util.isHex)(unknow, 680) && (0, _u8aFrom.default)(unknow).subarray(0, _defaults.PKCS8_HEADER.length).toString() === _defaults.PKCS8_HEADER.toString()) {
      return Account.fromPkcs8(unknow);
    } else {
      return Account.fromSeed(unknow);
    }
  }
  /**
    * @name fromMnemonic
    * @summary generate account using mnemonic
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static fromMnemonic(mnemonic) {
    const seed = (0, _utilCrypto.mnemonicToMiniSecret)(mnemonic);
    return new Account((0, _utilCrypto.naclKeypairFromSeed)(seed));
  }
  /**
    * @name fromPrivateKey
    * @summary generate account using mnemonic
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static fromPrivateKey(privateKey) {
    return Account.fromSeed(privateKey);
  }
  /**
     * Generate new public/secret keypair for Alice from the supplied seed
     * @param seedLike string
     */


  static fromSeed(seedLike) {
    const seedU8a = (0, _util.stringToU8a)(seedLike);
    return new Account((0, _utilCrypto.naclKeypairFromSeed)(seedU8a));
  }
  /***
     *
     * Generate new public/secret keypair for Alice from the supplied text
     * @param text string
     *
    */


  static fromText(text) {
    return Account.fromSeed(text);
  }
  /**
    * @name fromPrivateKey
    * @summary generate account using mnemonic
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static fromSecretKey(secretKey) {
    const secretKeyU8a = (0, _u8aFrom.default)(secretKey, 'hex');
    return new Account((0, _utilCrypto.naclKeypairFromSecret)(secretKeyU8a));
  }
  /**
    * @name fromPkcs8
    * @summary generate account using mnemonic
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static fromPkcs8(passphrase, encoded) {
    const decoded = (0, _decode.default)(passphrase, (0, _u8aFrom.default)(encoded));
    return new Account(decoded);
  }
  /**
    * @name fromJson
    * @summary generate account using mnemonic
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static fromJson(json, passphrase) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
    const encoded = json.encoded;
    if (!encoded) throw new Error('keystore 格式错误');
    const decoded = (0, _decode.default)(passphrase, (0, _u8aFrom.default)(encoded));
    return new Account(decoded);
  }
  /**
    * @name generate
    * @summary generate a random acountt
    * @description
    * Returns acount of publicKey and seceretKey.
    */


  static generate() {
    const random = (0, _utilCrypto.randomAsHex)(32);
    return Account.fromSeed(random);
  }
  /**
    * @name newMnemonic
    * @summary generate a random mnemonic
    * @description
    * Returns Mnemonic
    */


  static newMnemonic() {
    return (0, _utilCrypto.mnemonicGenerate)();
  }
  /**
    * @name isMnemonicValid
    * @summary if menonic is valid or invalid
    * @description
    * Returns true or false
    */


  static isMnemonicValid(mnemonic) {
    return (0, _utilCrypto.mnemonicValidate)(mnemonic);
  }
  /**
    * @name isAddressValid
    * @summary if address is valid or invalid
    * @description
    * Returns true or false
    */


  static isAddressValid(address) {
    try {
      (0, _keyring.encodeAddress)((0, _util.isHex)(address) ? (0, _util.hexToU8a)(address) : (0, _keyring.decodeAddress)(address));
    } catch (error) {
      return false;
    }

    return true;
  }
  /**
    * @name encodeAddress
    * @summary generate address from the publickKey
    * @description
    * Returns the address
    */


  static encodeAddress(pulickey) {
    return (0, _keyring.encodeAddress)(pulickey);
  }
  /**
    * @name decodeAddress
    * @summary generate address from the publickKey
    * @description
    * Returns the address
    */


  static decodeAddress(address, ignoreChecksum, prefix) {
    return (0, _util.u8aToHex)((0, _keyring.decodeAddress)(address, ignoreChecksum, prefix));
  }
  /**
    * @name encodePkcs8
    * @summary  generate pksc8 from the passphrase
    * @description
    * Returns the address
    */


  encodePkcs8(passphrase) {
    const publicKey = this._keyPair.publicKey;

    const seed = this._keyPair.secretKey.subarray(0, 32);

    const encoded = (0, _encode.default)({
      publicKey,
      seed
    }, passphrase);
    return {
      address: (0, _keyring.encodeAddress)(publicKey),
      encoded: (0, _util.u8aToHex)(encoded),
      encoding: {
        content: ['pkcs8', 'ed25519'],
        type: 'xsalsa20-poly1305',
        version: '1'
      }
    };
  }

}

exports.Account = Account;