"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hasPrefix = _interopRequireDefault(require("@chainx/util/hex/hasPrefix"));

var _stripPrefix = _interopRequireDefault(require("@chainx/util/hex/stripPrefix"));

var _addPrefix = _interopRequireDefault(require("@chainx/util/hex/addPrefix"));

var crypto = require('crypto-browserify');

var blakejs = require('blakejs');

var iterations = 10240;

var KeyStore =
/*#__PURE__*/
function () {
  function KeyStore() {
    (0, _classCallCheck2["default"])(this, KeyStore);
  }

  (0, _createClass2["default"])(KeyStore, null, [{
    key: "encrypt",
    value: function encrypt(rawPrivateKey, passphrase) {
      var privateKey = (0, _hasPrefix["default"])(rawPrivateKey) ? (0, _stripPrefix["default"])(rawPrivateKey) : rawPrivateKey;
      var salt = crypto.randomBytes(32);
      var derivedKey = crypto.pbkdf2Sync(passphrase, salt, iterations, 32, 'sha256');
      var derivedLeftKey = derivedKey.slice(0, 16);
      var derivedRightKey = derivedKey.slice(16);
      var iv = crypto.randomBytes(16);
      var cipher = crypto.createCipheriv('aes-128-ctr', derivedLeftKey, iv);
      var privateKeyInBuffer = Buffer.from(privateKey, 'hex');
      var ciphertext = cipher.update(privateKeyInBuffer);
      var macKey = Buffer.concat([derivedRightKey, ciphertext]);
      var mac = Buffer.from(blakejs.blake2b(macKey, null, 32));
      var raw = {
        iv: iv,
        mac: mac,
        salt: salt,
        ciphertext: ciphertext,
        iterations: iterations
      };
      return Object.entries(raw).reduce(function (result, _ref) {
        var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        if (value instanceof Buffer) {
          result[key] = value.toJSON().data;
        } else {
          result[key] = value;
        }

        return result;
      }, {});
    }
  }, {
    key: "decrypt",
    value: function decrypt(encrypted, passphrase) {
      var normalized = Object.entries(encrypted).reduce(function (result, _ref3) {
        var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (value.length) {
          result[key] = Buffer.from(value);
        } else {
          result[key] = value;
        }

        return result;
      }, {});
      var derivedKey = crypto.pbkdf2Sync(passphrase, normalized.salt, iterations, 32, 'sha256');
      var derivedLeftKey = derivedKey.slice(0, 16);
      var derivedRightKey = derivedKey.slice(16);
      var macKey = Buffer.concat([derivedRightKey, normalized.ciphertext]);
      var mac = Buffer.from(blakejs.blake2b(macKey, null, 32));

      if (!mac.equals(normalized.mac)) {
        throw new Error('invalid password');
      }

      var cipher = crypto.createDecipheriv('aes-128-ctr', derivedLeftKey, normalized.iv);
      var privateKeyInBuffer = cipher.update(normalized.ciphertext);
      return (0, _addPrefix["default"])(privateKeyInBuffer.toString('hex'));
    }
  }]);
  return KeyStore;
}();

var _default = KeyStore;
exports["default"] = _default;